{
  "id": "3f1e8b7d-9a3c-4d2b-8f6e-2b4d3c1a9f5e",
  "jobTitle": "Software Developer",
  "skills": [
    "Java",
    "Spring Boot",
    "Spring Cloud",
    "Microservices",
    "REST APIs",
    "GraphQL",
    "Kafka",
    "Docker",
    "Docker Compose",
    "Kubernetes",
    "Helm",
    "AWS",
    "Azure",
    "GCP",
    "Terraform",
    "CloudFormation",
    "CI/CD",
    "Git",
    "GitLab CI",
    "Azure DevOps",
    "SonarQube",
    "JUnit",
    "Mockito",
    "Agile",
    "Scrum",
    "Reactive Programming",
    "PostgreSQL"
  ],
  "certificates": [
    "AWS Certified Solutions Architect – Associate 03/2019",
    "Certified Kubernetes Administrator 08/2020",
    "Microsoft Certified: Azure Solutions Architect Expert 11/2021",
    "Scrum Master Certified 06/2022",
    "Oracle Certified Professional, Java SE 11 Developer 05/2020",
    "Docker Certified Associate 02/2021"
  ],
  "projectHistory": [
    {
      "name": "Entwicklung einer skalierbaren E‑Commerce-Plattform",
      "description": "Das Projekt umfasste die Konzeption und Implementierung einer vollständig skalierbaren E‑Commerce-Plattform, die auf einer Microservice‑Architektur basiert. Der Fokus lag auf der Nutzung von Java, Spring Boot und Kubernetes, um eine hochverfügbare Infrastruktur in AWS bereitzustellen. Wir setzten Docker-Container ein, um die Bereitstellung zu vereinfachen, und implementierten CI/CD-Pipelines mit Jenkins, die automatisierte Tests und Deployments ermöglichten. Die Anwendung nutzte PostgreSQL als Datenbank und unterstützte Zahlungsabwicklungen über REST‑APIs. Durch die Einführung von Monitoring und Logging mit Prometheus und Grafana erreichten wir eine hohe Zuverlässigkeit und schnellere Fehlerdiagnose.",
      "technologies": [
        "Java",
        "Spring Boot",
        "Kubernetes",
        "Docker",
        "AWS",
        "PostgreSQL",
        "CI/CD",
        "Jenkins",
        "Prometheus",
        "Grafana"
      ]
    },
    {
      "name": "Microservice‑Architektur für FinTech‑Payments",
      "description": "Bei diesem Projekt wurden Microservices für ein FinTech‑Payments‑System entwickelt, das Transaktionen in Echtzeit verarbeitet. Die Implementierung erfolgte mit Java, Spring Cloud und Kafka, um asynchrone Kommunikation sicherzustellen. Docker und Kubernetes wurden eingesetzt, um die Services in Azure bereitzustellen, während Terraform zur Infrastrukturautomatisierung verwendet wurde. CI/CD wurde über Azure DevOps realisiert, inklusive automatisierter Unit‑Tests mit JUnit und Integrationstests mit Mockito. Die Anwendung garantierte niedrige Latenzzeiten und hohe Skalierbarkeit, um auch bei Spitzenlasten stabile Zahlungsabwicklungen zu gewährleisten.",
      "technologies": [
        "Java",
        "Spring Cloud",
        "Kafka",
        "Docker",
        "Kubernetes",
        "Azure",
        "Terraform",
        "CI/CD",
        "Azure DevOps",
        "JUnit",
        "Mockito"
      ]
    },
    {
      "name": "Realtime Analytics Dashboard",
      "description": "Das Realtime Analytics Dashboard bot Echtzeit-Visualisierungen für Unternehmensdaten. Java und Spring Boot wurden verwendet, um REST‑ und GraphQL‑Endpoints bereitzustellen. Kafka stellte die Datenpipeline bereit, während Docker und Kubernetes die Services in AWS deployten. Terraform und Helm verwalteten die Cloud‑Infrastruktur. Durch die Nutzung von Docker‑Compose konnten lokale Entwicklungsumgebungen schnell eingerichtet werden. Die Anwendung integrierte moderne Front‑end‑Technologien und bot Benutzern die Möglichkeit, Metriken in Echtzeit zu analysieren.",
      "technologies": [
        "Java",
        "Spring Boot",
        "GraphQL",
        "Kafka",
        "Docker",
        "Kubernetes",
        "AWS",
        "Terraform",
        "Helm",
        "Docker Compose"
      ]
    },
    {
      "name": "Automatisierte DevOps Pipeline für SaaS Produkt",
      "description": "In diesem Projekt entwickelten wir eine vollständig automatisierte DevOps‑Pipeline für ein SaaS‑Produkt. Java und Spring Boot bildeten die Grundlage der Anwendung, während Docker und Kubernetes die Bereitstellung in Azure ermöglichten. Terraform orchestrierte die Infrastruktur, und GitLab CI führte kontinuierliche Integration und Delivery durch. SonarQube überwachte die Code‑Qualität, während Azure DevOps die Release‑Management‑Prozesse steuerte. Die Pipeline gewährleistete schnelle und fehlerfreie Releases, wodurch die Time‑to‑Market signifikant reduziert wurde.",
      "technologies": [
        "Java",
        "Spring Boot",
        "Docker",
        "Kubernetes",
        "Terraform",
        "GitLab CI",
        "SonarQube",
        "Azure DevOps"
      ]
    }
  ],
  "startingDate": "2018-01-01T00:00:00.000+00:00",
  "lastUpdate": "2025-11-13T14:29:17.000+00:00"
}